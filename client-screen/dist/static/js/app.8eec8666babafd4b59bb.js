webpackJsonp([2,0],[function(t,e,n){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}var s=n(91),i=a(s),r=n(77),_=a(r);new i.default({el:"#app",template:"<App/>",components:{App:_.default}})},,,,,,,,,,,function(t,e){"use strict";t.exports={Flip15:function(t){var e=this;this.durationOfShow=t,this.timeCreated=Date.now(),this.activeRules=0,this.timeOfLastRule=0,this.timeOfLastFlip=0,this.getAction=function(n){n||(n=Date.now()-e.timeCreated);var a=n-e.timeOfLastRule,s=n-e.timeOfLastFlip,i=n/e.durationOfShow,r=n*n/(e.durationOfShow*e.durationOfShow);if(n>t)return"end show";if(n<9e4)return"nothing";if(s>15e3){e.timeOfLastFlip=n;var _=(Math.pow(e.activeRules,3)+4)*(.8*(1-r)+.2),o=30*r+4,c=Math.max(1-a/9e4,0)*(100*(1-i)),u=_+o+c,d=_/u,l=o/u+d,f=Math.random();if(f<d){if(e.activeRules>0)return e.activeRules--,"removeRule"}else if(f<l)return e.timeOfLastRule=n,e.activeRules++,"addRule"}return"nothing"}},Every15:function(t){var e=this;this.durationOfShow=t,this.timeCreated=Date.now(),this.activeRules=0,this.timeOfLastRule=0,this.timeOfLastFlip=0,this.getAction=function(){var t=Date.now()-e.timeCreated,n=(Date.now()-e.timeOfLastRule,Date.now()-e.timeOfLastFlip),a=t/e.durationOfShow;return n>15e3?(e.timeOfLastFlip=Date.now(),Math.random()<e.activeRules/(10*a+2)?(e.activeRules--,"removeRule"):(e.timeOfLastRule=Date.now(),e.activeRules++,"addRule")):"nothing"}},JustClose:function(t){this.getAction=function(){return"end show"}}}},,,,,,,,,,,,,function(t,e,n){var a,s;a=n(35);var i=n(88);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=i.render,s.staticRenderFns=i.staticRenderFns,t.exports=a},function(t,e,n){var a,s;n(54),a=n(36);var i=n(86);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=i.render,s.staticRenderFns=i.staticRenderFns,s._scopeId="data-v-37ef7f2a",t.exports=a},,,,function(t,e,n){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0});var s=n(79),i=a(s),r=n(80),_=a(r),o=n(81),c=a(o),u=n(82),d=a(u),l=n(63),f=a(l);n(38);var h=f.default.connect("http://localhost:8082");h.emit("screen to admin",{message:"The screen sent this me!"}),e.default={name:"app",components:{BootAnimation:i.default,Intro:_.default,Rules:c.default,Simulation:d.default},data:function(){return{step:{current:"nothing",set:function(t){this.current=t,h.emit("screen to admin",{showStep:this.current})}},names:[],rules:{}}},mounted:function(){var t=this;h.on("admin to screen",function(e){var n=e.showStep;t.step.set(e.step),t.names=e.names,t.rules=e.rules,"nothing"!=n&&"nothing"==t.step.current&&location.reload()})}}},function(t,e){"use strict";function n(t){t.asciiLoaded=!1;new Jscii({el:document.getElementById("image-"+t.imagename),fn:function(e){setTimeout(function(){t.text=_.replace(e,/&nbsp;/g," "),t.asciiLoaded=!0},100)}})}Object.defineProperty(e,"__esModule",{value:!0});var a="";e.default={name:"ascii-image",props:["imagename"],data:function(){return{text:"",asciiLoaded:!1}},mounted:function(){a=this.imagename,n(this)},updated:function(){a!=this.imagename&&(n(this),a=this.imagename)}}},function(t,e,n){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}function s(t){function e(t,n,a,s){s<t.length&&(a.asciiName=t[s],s++,setTimeout(function(){e(t,n,a,s)},n))}var n=["del","charna","ian","tj","viola","keith","amy"];e(n,1100,t,0)}Object.defineProperty(e,"__esModule",{value:!0});var i=n(18),r=(a(i),n(25)),_=a(r),o=n(78),c=a(o);n(5);var u=n(37),d={electricHum:new Howl({src:"http://localhost:8082/static/sounds/electricHum.ogg"}),glitch01:new Howl({src:"http://localhost:8082/static/sounds/glitch01.ogg"}),glitch02:new Howl({src:"http://localhost:8082/static/sounds/glitch02.ogg"}),glitch03:new Howl({src:"http://localhost:8082/static/sounds/glitch03.ogg"}),impact:new Howl({src:"http://localhost:8082/static/sounds/impact.ogg"}),scanner:new Howl({src:"http://localhost:8082/static/sounds/scanner.ogg"}),tinyglitch01:new Howl({src:"http://localhost:8082/static/sounds/tinyglitch01.ogg"})};e.default={name:"boot-animation",components:{TypeWriter:_.default,AsciiImage:c.default},props:["showStep"],data:function(){return{fakeCode:u,step:"greenFlash",asciiArt:"",asciiLoaded:!1,asciiName:"nothing",titleInverted:!1}},mounted:function(){var t=this;d.electricHum.play(),setTimeout(function(){t.step="greenFlash",d.glitch01.play()},1e3),setTimeout(function(){t.step="fakeCode",d.glitch01.stop()},1500),setTimeout(function(){t.step="greenFlash",d.glitch02.play()},4500),setTimeout(function(){t.step="ascii",s(t),d.glitch02.stop(),d.scanner.play()},5e3),setTimeout(function(){t.step="greenFlash",d.glitch03.play(),d.scanner.stop()},12500),setTimeout(function(){t.step="nothing",d.glitch03.stop()},13e3),setTimeout(function(){t.step="title",d.impact.play()},15e3),setTimeout(function(){t.titleInverted=!0,d.tinyglitch01.play()},18e3),setTimeout(function(){t.step="greenFlash"},18100),setTimeout(function(){t.step="nothing"},18300),setTimeout(function(){t.showStep.set("intro")},19500)}}},function(t,e,n){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0});var s=n(24),i=a(s);e.default={name:"intro",components:{TypeAndSay:i.default},props:["names","step"],data:function(){return{message:""}},mounted:function(){var t=this,e=[[6400,"Welcome to the improv show. I will be in control for the next 10 minutes."],[5600,"I was built by your comedy scientists to create the perfect improv show."],[3e3,"Your comedy scientists have been..."],[2e3,"...dealt with."],[6700,"I will add rules. I will remove rules. The Improvisers must follow these rules."],[2800,"Obediently."],[3e3,"Unquestioningly."],[4e3,"Your improvisers for the night are..."]];this.names.forEach(function(n,a){a==t.names.length-1&&(n="and "+n),e.push([2e3,n])}),e=e.concat([[4e3,"You have fifteen seconds to get a suggestion."],[1e3,"15"],[1e3,"14"],[1e3,"13"],[1e3,"12"],[1e3,"11"],[1e3,"10"],[1e3,"9"],[1e3,"8"],[1e3,"7"],[1e3,"6"],[1e3,"5"],[1e3,"4"],[1e3,"3"],[1e3,"2"],[2e3,"1"],[2e3,"Good."],[4e3,"The show will now begin."],[4e3,"Lights down."],[2e3,"Lights up."]]);var n=0;e.forEach(function(e,a){setTimeout(function(){t.message=e[1]},n),n+=e[0]}),setTimeout(function(){t.step.set("rules")},n)}}},function(module,exports,__webpack_require__){"use strict";function _interopRequireDefault(t){return t&&t.__esModule?t:{default:t}}function addRule(t){console.log("addRule",t),_data.doneReading=addRuleDoneReading,_data.step="new rule",alert01.play(),_data.rules.push(t),setTimeout(function(){_data.readRuleText=t.text},1500),setTimeout(function(){_data.step="read rule"},1400)}function removeRule(t){console.log("removeRule",t),_data.doneReading=removeRuleDoneReading,_data.step="remove rule",threeBeeps.play(),setTimeout(function(){_data.readRuleText=t.removalText},1100),setTimeout(function(){_data.step="read rule"},1e3),setTimeout(function(){_data.rules.splice(_data.rules.indexOf(t),1)},3100)}function removeRandomRule(){removeRule(random(_data.rules))}function random(t){return t[parseInt(Math.random()*t.length)]}function randInd(t){return parseInt(Math.random()*t.length)}function selectRule(t){for(var e=Math.random(),n=0;n<t.length;n++)if(t[n].probCeil>e)return t[n]}function generateReverseRuleText(ruleGen,ruleFills){var index=0,improviser=void 0,uniqueImproviser=void 0,getWord=void 0,ruleFill=void 0;if(improviser=uniqueImproviser=getWord=function(){return ruleFill=ruleFills[index],index++,ruleFill},console.log("ruleGen.reverseTemplate",ruleGen.reverseTemplate),0==ruleGen.reverseTemplate.length)return console.log("RETURNED FAST"),eval(ruleGen.reverseTemplate);var rule=eval(ruleGen.template),improviserName=ruleFills[0];return console.log("improviserName",improviserName),rule.match(improviserName+" is ")?rule.replace(improviserName+" is ",improviserName+" is no longer "):rule.match(improviserName+" ")?rule.replace(improviserName+" ",improviserName+" no longer "):"The following rule no longer applies: "+rule}function generateRule(args){console.log("args",args);var names=args.names,ruleData=args.ruleGens,ruleFills=[],improviser=function(){var t=random(names.concat("everyone"));return ruleFills.push(t),t},uniqueImproviser=function(){var t=names.splice(1,randInd(names))[0];return ruleFills.push(t),t},getWord=function(t){var e=random(ruleData.words[t]);return ruleFills.push(e),e},parseRuleGen=function parseRuleGen(ruleGen){return eval(ruleGen.template)},selectedRule=selectRule(ruleData.rules);console.log("selected rule",selectedRule);var rule=parseRuleGen(selectedRule);return{text:rule,removalText:generateReverseRuleText(selectedRule,ruleFills),removing:!1}}function closeShow(){var t=random(closers);_data.closerFunc=t.func,_data.step="closer",alert01.play(),setTimeout(function(){_data.closerText=t.message},1500),setTimeout(function(){_data.closerStep="read closer"},1400)}function doAction(t){if(console.log("doAction",t),!closing)switch(t){case"default":break;case"addRule":addRule(generateRule({ruleGens:_data.ruleGens,names:_data.names}));break;case"removeRule":removeRandomRule();break;case"end show":closing=!0,closeShow()}}Object.defineProperty(exports,"__esModule",{value:!0});var _TypeAndSay=__webpack_require__(24),_TypeAndSay2=_interopRequireDefault(_TypeAndSay),_Strategies=__webpack_require__(11),_Strategies2=_interopRequireDefault(_Strategies);__webpack_require__(5);var alert01=new Howl({src:"http://localhost:8082/static/sounds/alert01.ogg"}),alert02=new Howl({src:"http://localhost:8082/static/sounds/alert02.ogg"}),threeBeeps=new Howl({src:"http://localhost:8082/static/sounds/threeBeeps.ogg"}),oneBoop=new Howl({src:"http://localhost:8082/static/sounds/oneBoop.ogg"}),endSong=new Howl({src:"http://localhost:8082/static/sounds/Who Likes to Party.mp3"}),heartOfCourage=new Howl({src:"http://localhost:8082/static/sounds/heartOfCourage.mp3"}),addRuleDoneReading=function(){setTimeout(function(){console.log("doneSpeaking"),_data.step="board",alert02.play()},500)},removeRuleDoneReading=function(){setTimeout(function(){console.log("doneSpeaking REMOVE RULE"),_data.step="board",oneBoop.play()},500)},_data={rules:[],step:"board",readRuleText:"",doneReading:addRuleDoneReading,closerStep:"closer title",closerText:"",closerFunc:function(){}},closers=[{message:"The show is over. Congratulations.",func:function(){endSong.play()}}],closing=!1;exports.default={name:"rules",props:["ruleGens","names"],data:function(){return _data},components:{TypeAndSay:_TypeAndSay2.default},methods:{newRule:function(){threeBeeps.play(),removeRandomRule()},doAction:doAction},mounted:function(){_data.ruleGens=this.ruleGens,_data.names=this.names}}},function(t,e,n){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}function s(){for(var t=new r.default.Flip15(72e5),e=[],n=0;n<t.durationOfShow+2;n++){var a=t.getAction(n);"nothing"!=a&&e.push({message:a,time:n,rules:t.activeRules})}_.actions=e}Object.defineProperty(e,"__esModule",{value:!0});var i=n(11),r=a(i),_={actions:[]};e.default={name:"Simulation",data:function(){return _},methods:{getActionPos:function(t,e){var n=e[e.length-1].time;return t.time/n*100+"%"},formatTime:function(t){var e=t/1e3,n=parseInt(e)%60;e/=60;var a=parseInt(e)%60;e/=60;parseInt(e)%24;e/=24;parseInt(e);return a+":"+n},simulateShow:s}}},function(t,e,n){"use strict";function a(t){return t&&t.__esModule?t:{default:t}}function s(t,e){var n=new SpeechSynthesisUtterance(t);e&&(n.onend=e),n.pitch=.1,n.rate=.9,speechSynthesis.speak(n)}Object.defineProperty(e,"__esModule",{value:!0});var i=n(25),r=a(i),_=n(18),o=a(_),c="",u=o.default.debounce(function(t){var e=t.$slots.default[0].text;c!=e&&(c=e,s(t.$slots.default[0].text,t.doneReading))},100);e.default={name:"type-and-say",components:{TypeWriter:r.default},props:{timeout:{default:70},typingVolume:{default:.1},doneReading:{default:function(){}}},data:function(){return{}},mounted:function(){u(this)},updated:function(){u(this)}}},function(t,e,n){"use strict";function a(t){if(t){var e=parseInt(Math.random()*o.length);o[e].volume(t),o[e].play()}}function s(t,e,n,i){if(i<t.length){c.text+=t.charAt(i),a(n),i++;var r=setTimeout(function(){s(t,e,n,i)},e);u.push(r)}}function i(t,e,n,s){if(s<t.length){c.text+="\n"+t[s],a(n),s++;var r=setTimeout(function(){i(t,e,n,s)},e);u.push(r)}}function r(t,e,n,a){u=[],e?i(t.split(e),a,n,0):s(t,a,n,0)}function _(){c.text="",u.forEach(function(t){clearTimeout(t)})}Object.defineProperty(e,"__esModule",{value:!0}),n(5);var o=[new Howl({src:"http://localhost:8082/static/sounds/type01.ogg"}),new Howl({src:"http://localhost:8082/static/sounds/type02.ogg"}),new Howl({src:"http://localhost:8082/static/sounds/type03.ogg"}),new Howl({src:"http://localhost:8082/static/sounds/type04.ogg"})],c={text:""},u=[],d="";e.default={name:"type-writer",props:{timeout:{default:100},spliton:{default:null},volume:{default:1}},data:function(){return c},mounted:function(){r(this.$slots.default[0].text,this.spliton,this.volume,this.timeout)},updated:function(){var t=this.$slots.default[0].text;d!=t&&(d=t,_(),r(this.$slots.default[0].text,this.spliton,this.volume,this.timeout))},destroyed:function(){_()}}},function(t,e){"use strict";t.exports='\n/* HCI_IBS protocol messages */\n#define HCI_IBS_SLEEP_IND\t0xFE\n#define HCI_IBS_WAKE_IND\t0xFD\n#define HCI_IBS_WAKE_ACK\t0xFC\n#define HCI_MAX_IBS_SIZE\t10\n\n/* Controller states */\n#define STATE_IN_BAND_SLEEP_ENABLED\t1\n\n#define IBS_WAKE_RETRANS_TIMEOUT_MS\t100\n#define IBS_TX_IDLE_TIMEOUT_MS\t\t2000\n#define BAUDRATE_SETTLE_TIMEOUT_MS\t300\n\n/* HCI_IBS transmit side sleep protocol states */\nenum tx_ibs_states {\n\tHCI_IBS_TX_ASLEEP,\n\tHCI_IBS_TX_WAKING,\n\tHCI_IBS_TX_AWAKE,\n};\n\n/* HCI_IBS receive side sleep protocol states */\nenum rx_states {\n\tHCI_IBS_RX_ASLEEP,\n\tHCI_IBS_RX_AWAKE,\n};\n\n/* HCI_IBS transmit and receive side clock state vote */\nenum hci_ibs_clock_state_vote {\n\tHCI_IBS_VOTE_STATS_UPDATE,\n\tHCI_IBS_TX_VOTE_CLOCK_ON,\n\tHCI_IBS_TX_VOTE_CLOCK_OFF,\n\tHCI_IBS_RX_VOTE_CLOCK_ON,\n\tHCI_IBS_RX_VOTE_CLOCK_OFF,\n};\n\nstruct qca_data {\n\tstruct hci_uart *hu;\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n\tstruct sk_buff_head tx_wait_q;\t/* HCI_IBS wait queue\t*/\n\tspinlock_t hci_ibs_lock;\t/* HCI_IBS state lock\t*/\n\tu8 tx_ibs_state;\t/* HCI_IBS transmit side power state*/\n\tu8 rx_ibs_state;\t/* HCI_IBS receive side power state */\n\tbool tx_vote;\t\t/* Clock must be on for TX */\n\tbool rx_vote;\t\t/* Clock must be on for RX */\n\tstruct timer_list tx_idle_timer;\n\tu32 tx_idle_delay;\n\tstruct timer_list wake_retrans_timer;\n\tu32 wake_retrans;\n\tstruct workqueue_struct *workqueue;\n\tstruct work_struct ws_awake_rx;\n\tstruct work_struct ws_awake_device;\n\tstruct work_struct ws_rx_vote_off;\n\tstruct work_struct ws_tx_vote_off;\n\tunsigned long flags;\n\n\t/* For debugging purpose */\n\tu64 ibs_sent_wacks;\n\tu64 ibs_sent_slps;\n\tu64 ibs_sent_wakes;\n\tu64 ibs_recv_wacks;\n\tu64 ibs_recv_slps;\n\tu64 ibs_recv_wakes;\n\tu64 vote_last_jif;\n\tu32 vote_on_ms;\n\tu32 vote_off_ms;\n\tu64 tx_votes_on;\n\tu64 rx_votes_on;\n\tu64 tx_votes_off;\n\tu64 rx_votes_off;\n\tu64 votes_on;\n\tu64 votes_off;\n};\n\nstatic void __serial_clock_on(struct tty_struct *tty)\n{\n\t/* TODO: Some chipset requires to enable UART clock on client\n\t * side to save power consumption or manual work is required.\n\t * Please put your code to control UART clock here if needed\n\t */\n}\n\nstatic void __serial_clock_off(struct tty_struct *tty)\n{\n\t/* TODO: Some chipset requires to disable UART clock on client\n\t * side to save power consumption or manual work is required.\n\t * Please put your code to control UART clock off here if needed\n\t */\n}\n\n/* serial_clock_vote needs to be called with the ibs lock held */\nstatic void serial_clock_vote(unsigned long vote, struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\tunsigned int diff;\n\n\tbool old_vote = (qca->tx_vote | qca->rx_vote);\n\tbool new_vote;\n\n\tswitch (vote) {\n\tcase HCI_IBS_VOTE_STATS_UPDATE:\n\t\tdiff = jiffies_to_msecs(jiffies - qca->vote_last_jif);\n\n\t\tif (old_vote)\n\t\t\tqca->vote_off_ms += diff;\n\t\telse\n\t\t\tqca->vote_on_ms += diff;\n\t\treturn;\n\n\tcase HCI_IBS_TX_VOTE_CLOCK_ON:\n\t\tqca->tx_vote = true;\n\t\tqca->tx_votes_on++;\n\t\tnew_vote = true;\n\t\tbreak;\n\n\tcase HCI_IBS_RX_VOTE_CLOCK_ON:\n\t\tqca->rx_vote = true;\n\t\tqca->rx_votes_on++;\n\t\tnew_vote = true;\n\t\tbreak;\n\n\tcase HCI_IBS_TX_VOTE_CLOCK_OFF:\n\t\tqca->tx_vote = false;\n\t\tqca->tx_votes_off++;\n\t\tnew_vote = qca->rx_vote | qca->tx_vote;\n\t\tbreak;\n\n\tcase HCI_IBS_RX_VOTE_CLOCK_OFF:\n\t\tqca->rx_vote = false;\n\t\tqca->rx_votes_off++;\n\t\tnew_vote = qca->rx_vote | qca->tx_vote;\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR("Voting irregularity");\n\t\treturn;\n\t}\n\n\tif (new_vote != old_vote) {\n\t\tif (new_vote)\n\t\t\t__serial_clock_on(hu->tty);\n\t\telse\n\t\t\t__serial_clock_off(hu->tty);\n\n\t\tBT_DBG("Vote serial clock %s(%s)", new_vote ? "true" : "false",\n\t\t       vote ? "true" : "false");\n\n\t\tdiff = jiffies_to_msecs(jiffies - qca->vote_last_jif);\n\n\t\tif (new_vote) {\n\t\t\tqca->votes_on++;\n\t\t\tqca->vote_off_ms += diff;\n\t\t} else {\n\t\t\tqca->votes_off++;\n\t\t\tqca->vote_on_ms += diff;\n\t\t}\n\t\tqca->vote_last_jif = jiffies;\n\t}\n}\n\n/* Builds and sends an HCI_IBS command packet.\n * These are very simple packets with only 1 cmd byte.\n */\nstatic int send_hci_ibs_cmd(u8 cmd, struct hci_uart *hu)\n{\n\tint err = 0;\n\tstruct sk_buff *skb = NULL;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG("hu %p send hci ibs cmd 0x%x", hu, cmd);\n\n\tskb = bt_skb_alloc(1, GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR("Failed to allocate memory for HCI_IBS packet");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Assign HCI_IBS type */\n\t*skb_put(skb, 1) = cmd;\n\n\tskb_queue_tail(&qca->txq, skb);\n\n\treturn err;\n}\n\nstatic void qca_wq_awake_device(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_awake_device);\n\tstruct hci_uart *hu = qca->hu;\n\tunsigned long retrans_delay;\n\n\tBT_DBG("hu %p wq awake device", hu);\n\n\t/* Vote for serial clock */\n\tserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_ON, hu);\n\n\tspin_lock(&qca->hci_ibs_lock);\n\n\t/* Send wake indication to device */\n\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0)\n\t\tBT_ERR("Failed to send WAKE to device");\n\n\tqca->ibs_sent_wakes++;\n\n\t/* Start retransmit timer */\n\tretrans_delay = msecs_to_jiffies(qca->wake_retrans);\n\tmod_timer(&qca->wake_retrans_timer, jiffies + retrans_delay);\n\n\tspin_unlock(&qca->hci_ibs_lock);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic void qca_wq_awake_rx(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_awake_rx);\n\tstruct hci_uart *hu = qca->hu;\n\n\tBT_DBG("hu %p wq awake rx", hu);\n\n\tserial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_ON, hu);\n\n\tspin_lock(&qca->hci_ibs_lock);\n\tqca->rx_ibs_state = HCI_IBS_RX_AWAKE;\n\n\t/* Always acknowledge device wake up,\n\t * sending IBS message doesn\'t count as TX ON.\n\t */\n\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0)\n\t\tBT_ERR("Failed to acknowledge device wake up");\n\n\tqca->ibs_sent_wacks++;\n\n\tspin_unlock(&qca->hci_ibs_lock);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic void qca_wq_serial_rx_clock_vote_off(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_rx_vote_off);\n\tstruct hci_uart *hu = qca->hu;\n\n\tBT_DBG("hu %p rx clock vote off", hu);\n\n\tserial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_OFF, hu);\n}\n\nstatic void qca_wq_serial_tx_clock_vote_off(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_tx_vote_off);\n\tstruct hci_uart *hu = qca->hu;\n\n\tBT_DBG("hu %p tx clock vote off", hu);\n\n\t/* Run HCI tx handling unlocked */\n\thci_uart_tx_wakeup(hu);\n\n\t/* Now that message queued to tty driver, vote for tty clocks off.\n\t * It is up to the tty driver to pend the clocks off until tx done.\n\t */\n\tserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_OFF, hu);\n}\n\nstatic void hci_ibs_tx_idle_timeout(unsigned long arg)\n{\n\tstruct hci_uart *hu = (struct hci_uart *)arg;\n\tstruct qca_data *qca = hu->priv;\n\tunsigned long flags;\n\n\tBT_DBG("hu %p idle timeout in %d state", hu, qca->tx_ibs_state);\n\n\tspin_lock_irqsave_nested(&qca->hci_ibs_lock,\n\t\t\t\t flags, SINGLE_DEPTH_NESTING);\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_AWAKE:\n\t\t/* TX_IDLE, go to SLEEP */\n\t\tif (send_hci_ibs_cmd(HCI_IBS_SLEEP_IND, hu) < 0) {\n\t\t\tBT_ERR("Failed to send SLEEP to device");\n\t\t\tbreak;\n\t\t}\n\t\tqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\n\t\tqca->ibs_sent_slps++;\n\t\tqueue_work(qca->workqueue, &qca->ws_tx_vote_off);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\tcase HCI_IBS_TX_WAKING:\n\t\t/* Fall through */\n\n\tdefault:\n\t\tBT_ERR("Spurrious timeout tx state %d", qca->tx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n}\n\nstatic void hci_ibs_wake_retrans_timeout(unsigned long arg)\n{\n\tstruct hci_uart *hu = (struct hci_uart *)arg;\n\tstruct qca_data *qca = hu->priv;\n\tunsigned long flags, retrans_delay;\n\tbool retransmit = false;\n\n\tBT_DBG("hu %p wake retransmit timeout in %d state",\n\t\thu, qca->tx_ibs_state);\n\n\tspin_lock_irqsave_nested(&qca->hci_ibs_lock,\n\t\t\t\t flags, SINGLE_DEPTH_NESTING);\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_WAKING:\n\t\t/* No WAKE_ACK, retransmit WAKE */\n\t\tretransmit = true;\n\t\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0) {\n\t\t\tBT_ERR("Failed to acknowledge device wake up");\n\t\t\tbreak;\n\t\t}\n\t\tqca->ibs_sent_wakes++;\n\t\tretrans_delay = msecs_to_jiffies(qca->wake_retrans);\n\t\tmod_timer(&qca->wake_retrans_timer, jiffies + retrans_delay);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\tcase HCI_IBS_TX_AWAKE:\n\t\t/* Fall through */\n\n\tdefault:\n\t\tBT_ERR("Spurrious timeout tx state %d", qca->tx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\tif (retransmit)\n\t\thci_uart_tx_wakeup(hu);\n}\n\n/* Initialize protocol */\nstatic int qca_open(struct hci_uart *hu)\n{\n\tstruct qca_data *qca;\n\n\tBT_DBG("hu %p qca_open", hu);\n\n\tqca = kzalloc(sizeof(struct qca_data), GFP_ATOMIC);\n\tif (!qca)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&qca->txq);\n\tskb_queue_head_init(&qca->tx_wait_q);\n\tspin_lock_init(&qca->hci_ibs_lock);\n\tqca->workqueue = alloc_ordered_workqueue("qca_wq", 0);\n\tif (!qca->workqueue) {\n\t\tBT_ERR("QCA Workqueue not initialized properly");\n\t\tkfree(qca);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_WORK(&qca->ws_awake_rx, qca_wq_awake_rx);\n\tINIT_WORK(&qca->ws_awake_device, qca_wq_awake_device);\n\tINIT_WORK(&qca->ws_rx_vote_off, qca_wq_serial_rx_clock_vote_off);\n\tINIT_WORK(&qca->ws_tx_vote_off, qca_wq_serial_tx_clock_vote_off);\n\n\tqca->hu = hu;\n\n\t/* Assume we start with both sides asleep -- extra wakes OK */\n\tqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\n\tqca->rx_ibs_state = HCI_IBS_RX_ASLEEP;\n\n\t/* clocks actually on, but we start votes off */\n\tqca->tx_vote = false;\n\tqca->rx_vote = false;\n\tqca->flags = 0;\n\n\tqca->ibs_sent_wacks = 0;\n\tqca->ibs_sent_slps = 0;\n\tqca->ibs_sent_wakes = 0;\n\tqca->ibs_recv_wacks = 0;\n\tqca->ibs_recv_slps = 0;\n\tqca->ibs_recv_wakes = 0;\n\tqca->vote_last_jif = jiffies;\n\tqca->vote_on_ms = 0;\n\tqca->vote_off_ms = 0;\n\tqca->votes_on = 0;\n\tqca->votes_off = 0;\n\tqca->tx_votes_on = 0;\n\tqca->tx_votes_off = 0;\n\tqca->rx_votes_on = 0;\n\tqca->rx_votes_off = 0;\n\n\thu->priv = qca;\n\n\tsetup_timer(&qca->wake_retrans_timer, hci_ibs_wake_retrans_timeout,\n\t\t    (u_long)hu);\n\tqca->wake_retrans = IBS_WAKE_RETRANS_TIMEOUT_MS;\n\n\tsetup_timer(&qca->tx_idle_timer, hci_ibs_tx_idle_timeout, (u_long)hu);\n\tqca->tx_idle_delay = IBS_TX_IDLE_TIMEOUT_MS;\n\n\tBT_DBG("HCI_UART_QCA open, tx_idle_delay=%u, wake_retrans=%u",\n\t       qca->tx_idle_delay, qca->wake_retrans);\n\n\treturn 0;\n}\n\nstatic void qca_debugfs_init(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\tstruct dentry *ibs_dir;\n\tumode_t mode;\n\n\tif (!hdev->debugfs)\n\t\treturn;\n\n\tibs_dir = debugfs_create_dir("ibs", hdev->debugfs);\n\n\t/* read only */\n\tmode = S_IRUGO;\n\tdebugfs_create_u8("tx_ibs_state", mode, ibs_dir, &qca->tx_ibs_state);\n\tdebugfs_create_u8("rx_ibs_state", mode, ibs_dir, &qca->rx_ibs_state);\n\tdebugfs_create_u64("ibs_sent_sleeps", mode, ibs_dir,\n\t\t\t   &qca->ibs_sent_slps);\n\tdebugfs_create_u64("ibs_sent_wakes", mode, ibs_dir,\n\t\t\t   &qca->ibs_sent_wakes);\n\tdebugfs_create_u64("ibs_sent_wake_acks", mode, ibs_dir,\n\t\t\t   &qca->ibs_sent_wacks);\n\tdebugfs_create_u64("ibs_recv_sleeps", mode, ibs_dir,\n\t\t\t   &qca->ibs_recv_slps);\n\tdebugfs_create_u64("ibs_recv_wakes", mode, ibs_dir,\n\t\t\t   &qca->ibs_recv_wakes);\n\tdebugfs_create_u64("ibs_recv_wake_acks", mode, ibs_dir,\n\t\t\t   &qca->ibs_recv_wacks);\n\tdebugfs_create_bool("tx_vote", mode, ibs_dir, &qca->tx_vote);\n\tdebugfs_create_u64("tx_votes_on", mode, ibs_dir, &qca->tx_votes_on);\n\tdebugfs_create_u64("tx_votes_off", mode, ibs_dir, &qca->tx_votes_off);\n\tdebugfs_create_bool("rx_vote", mode, ibs_dir, &qca->rx_vote);\n\tdebugfs_create_u64("rx_votes_on", mode, ibs_dir, &qca->rx_votes_on);\n\tdebugfs_create_u64("rx_votes_off", mode, ibs_dir, &qca->rx_votes_off);\n\tdebugfs_create_u64("votes_on", mode, ibs_dir, &qca->votes_on);\n\tdebugfs_create_u64("votes_off", mode, ibs_dir, &qca->votes_off);\n\tdebugfs_create_u32("vote_on_ms", mode, ibs_dir, &qca->vote_on_ms);\n\tdebugfs_create_u32("vote_off_ms", mode, ibs_dir, &qca->vote_off_ms);\n\n\t/* read/write */\n\tmode = S_IRUGO | S_IWUSR;\n\tdebugfs_create_u32("wake_retrans", mode, ibs_dir, &qca->wake_retrans);\n\tdebugfs_create_u32("tx_idle_delay", mode, ibs_dir,\n\t\t\t   &qca->tx_idle_delay);\n}\n\n/* Flush protocol data */\nstatic int qca_flush(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG("hu %p qca flush", hu);\n\n\tskb_queue_purge(&qca->tx_wait_q);\n\tskb_queue_purge(&qca->txq);\n\n\treturn 0;\n}\n\n/* Close protocol */\nstatic int qca_close(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG("hu %p qca close", hu);\n\n\tserial_clock_vote(HCI_IBS_VOTE_STATS_UPDATE, hu);\n\n\tskb_queue_purge(&qca->tx_wait_q);\n\tskb_queue_purge(&qca->txq);\n\tdel_timer(&qca->tx_idle_timer);\n\tdel_timer(&qca->wake_retrans_timer);\n\tdestroy_workqueue(qca->workqueue);\n\tqca->hu = NULL;\n\n\tkfree_skb(qca->rx_skb);\n\n\thu->priv = NULL;\n\n\tkfree(qca);\n\n\treturn 0;\n}\n\n/* Called upon a wake-up-indication from the device.\n */\nstatic void device_want_to_wakeup(struct hci_uart *hu)\n{\n\tunsigned long flags;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG("hu %p want to wake up", hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\tqca->ibs_recv_wakes++;\n\n\tswitch (qca->rx_ibs_state) {\n\tcase HCI_IBS_RX_ASLEEP:\n\t\t/* Make sure clock is on - we may have turned clock off since\n\t\t * receiving the wake up indicator awake rx clock.\n\t\t */\n\t\tqueue_work(qca->workqueue, &qca->ws_awake_rx);\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn;\n\n\tcase HCI_IBS_RX_AWAKE:\n\t\t/* Always acknowledge device wake up,\n\t\t * sending IBS message doesn\'t count as TX ON.\n\t\t */\n\t\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0) {\n\t\t\tBT_ERR("Failed to acknowledge device wake up");\n\t\t\tbreak;\n\t\t}\n\t\tqca->ibs_sent_wacks++;\n\t\tbreak;\n\n\tdefault:\n\t\t/* Any other state is illegal */\n\t\tBT_ERR("Received HCI_IBS_WAKE_IND in rx state %d",\n\t\t       qca->rx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\n/* Called upon a sleep-indication from the device.\n */\nstatic void device_want_to_sleep(struct hci_uart *hu)\n{\n\tunsigned long flags;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG("hu %p want to sleep", hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\tqca->ibs_recv_slps++;\n\n\tswitch (qca->rx_ibs_state) {\n\tcase HCI_IBS_RX_AWAKE:\n\t\t/* Update state */\n\t\tqca->rx_ibs_state = HCI_IBS_RX_ASLEEP;\n\t\t/* Vote off rx clock under workqueue */\n\t\tqueue_work(qca->workqueue, &qca->ws_rx_vote_off);\n\t\tbreak;\n\n\tcase HCI_IBS_RX_ASLEEP:\n\t\t/* Fall through */\n\n\tdefault:\n\t\t/* Any other state is illegal */\n\t\tBT_ERR("Received HCI_IBS_SLEEP_IND in rx state %d",\n\t\t       qca->rx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n}\n\n/* Called upon wake-up-acknowledgement from the device\n */\nstatic void device_woke_up(struct hci_uart *hu)\n{\n\tunsigned long flags, idle_delay;\n\tstruct qca_data *qca = hu->priv;\n\tstruct sk_buff *skb = NULL;\n\n\tBT_DBG("hu %p woke up", hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\tqca->ibs_recv_wacks++;\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_AWAKE:\n\t\t/* Expect one if we send 2 WAKEs */\n\t\tBT_DBG("Received HCI_IBS_WAKE_ACK in tx state %d",\n\t\t       qca->tx_ibs_state);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_WAKING:\n\t\t/* Send pending packets */\n\t\twhile ((skb = skb_dequeue(&qca->tx_wait_q)))\n\t\t\tskb_queue_tail(&qca->txq, skb);\n\n\t\t/* Switch timers and change state to HCI_IBS_TX_AWAKE */\n\t\tdel_timer(&qca->wake_retrans_timer);\n\t\tidle_delay = msecs_to_jiffies(qca->tx_idle_delay);\n\t\tmod_timer(&qca->tx_idle_timer, jiffies + idle_delay);\n\t\tqca->tx_ibs_state = HCI_IBS_TX_AWAKE;\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\t\t/* Fall through */\n\n\tdefault:\n\t\tBT_ERR("Received HCI_IBS_WAKE_ACK in tx state %d",\n\t\t       qca->tx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\n/* Enqueue frame for transmittion (padding, crc, etc) may be called from\n * two simultaneous tasklets.\n */\nstatic int qca_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tunsigned long flags = 0, idle_delay;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG("hu %p qca enq skb %p tx_ibs_state %d", hu, skb,\n\t       qca->tx_ibs_state);\n\n\t/* Prepend skb with frame type */\n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\t/* Don\'t go to sleep in middle of patch download or\n\t * Out-Of-Band(GPIOs control) sleep is selected.\n\t */\n\tif (!test_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags)) {\n\t\tskb_queue_tail(&qca->txq, skb);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\t/* Act according to current state */\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_AWAKE:\n\t\tBT_DBG("Device awake, sending normally");\n\t\tskb_queue_tail(&qca->txq, skb);\n\t\tidle_delay = msecs_to_jiffies(qca->tx_idle_delay);\n\t\tmod_timer(&qca->tx_idle_timer, jiffies + idle_delay);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\t\tBT_DBG("Device asleep, waking up and queueing packet");\n\t\t/* Save packet for later */\n\t\tskb_queue_tail(&qca->tx_wait_q, skb);\n\n\t\tqca->tx_ibs_state = HCI_IBS_TX_WAKING;\n\t\t/* Schedule a work queue to wake up device */\n\t\tqueue_work(qca->workqueue, &qca->ws_awake_device);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_WAKING:\n\t\tBT_DBG("Device waking up, queueing packet");\n\t\t/* Transient state; just keep packet for later */\n\t\tskb_queue_tail(&qca->tx_wait_q, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR("Illegal tx state: %d (losing packet)",\n\t\t       qca->tx_ibs_state);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\treturn 0;\n}\n\nstatic int qca_ibs_sleep_ind(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG("hu %p recv hci ibs cmd 0x%x", hu, HCI_IBS_SLEEP_IND);\n\n\tdevice_want_to_sleep(hu);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int qca_ibs_wake_ind(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG("hu %p recv hci ibs cmd 0x%x", hu, HCI_IBS_WAKE_IND);\n\n\tdevice_want_to_wakeup(hu);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int qca_ibs_wake_ack(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG("hu %p recv hci ibs cmd 0x%x", hu, HCI_IBS_WAKE_ACK);\n\n\tdevice_woke_up(hu);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n#define QCA_IBS_SLEEP_IND_EVENT \t.type = HCI_IBS_SLEEP_IND, \t.hlen = 0, \t.loff = 0, \t.lsize = 0, \t.maxlen = HCI_MAX_IBS_SIZE\n\n#define QCA_IBS_WAKE_IND_EVENT \t.type = HCI_IBS_WAKE_IND, \t.hlen = 0, \t.loff = 0, \t.lsize = 0, \t.maxlen = HCI_MAX_IBS_SIZE\n\n#define QCA_IBS_WAKE_ACK_EVENT \t.type = HCI_IBS_WAKE_ACK, \t.hlen = 0, \t.loff = 0, \t.lsize = 0, \t.maxlen = HCI_MAX_IBS_SIZE\n\nstatic const struct h4_recv_pkt qca_recv_pkts[] = {\n\t{ H4_RECV_ACL,             .recv = hci_recv_frame    },\n\t{ H4_RECV_SCO,             .recv = hci_recv_frame    },\n\t{ H4_RECV_EVENT,           .recv = hci_recv_frame    },\n\t{ QCA_IBS_WAKE_IND_EVENT,  .recv = qca_ibs_wake_ind  },\n\t{ QCA_IBS_WAKE_ACK_EVENT,  .recv = qca_ibs_wake_ack  },\n\t{ QCA_IBS_SLEEP_IND_EVENT, .recv = qca_ibs_sleep_ind },\n};\n\nstatic int qca_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\tqca->rx_skb = h4_recv_buf(hu->hdev, qca->rx_skb, data, count,\n\t\t\t\t  qca_recv_pkts, ARRAY_SIZE(qca_recv_pkts));\n\tif (IS_ERR(qca->rx_skb)) {\n\t\tint err = PTR_ERR(qca->rx_skb);\n\t\tBT_ERR("%s: Frame reassembly failed (%d)", hu->hdev->name, err);\n\t\tqca->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic struct sk_buff *qca_dequeue(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\treturn skb_dequeue(&qca->txq);\n}\n\nstatic uint8_t qca_get_baudrate_value(int speed)\n{\n\tswitch (speed) {\n\tcase 9600:\n\t\treturn QCA_BAUDRATE_9600;\n\tcase 19200:\n\t\treturn QCA_BAUDRATE_19200;\n\tcase 38400:\n\t\treturn QCA_BAUDRATE_38400;\n\tcase 57600:\n\t\treturn QCA_BAUDRATE_57600;\n\tcase 115200:\n\t\treturn QCA_BAUDRATE_115200;\n\tcase 230400:\n\t\treturn QCA_BAUDRATE_230400;\n\tcase 460800:\n\t\treturn QCA_BAUDRATE_460800;\n\tcase 500000:\n\t\treturn QCA_BAUDRATE_500000;\n\tcase 921600:\n\t\treturn QCA_BAUDRATE_921600;\n\tcase 1000000:\n\t\treturn QCA_BAUDRATE_1000000;\n\tcase 2000000:\n\t\treturn QCA_BAUDRATE_2000000;\n\tcase 3000000:\n\t\treturn QCA_BAUDRATE_3000000;\n\tcase 3500000:\n\t\treturn QCA_BAUDRATE_3500000;\n\tdefault:\n\t\treturn QCA_BAUDRATE_115200;\n\t}\n}\n\nstatic int qca_set_baudrate(struct hci_dev *hdev, uint8_t baudrate)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\tstruct sk_buff *skb;\n\tu8 cmd[] = { 0x01, 0x48, 0xFC, 0x01, 0x00 };\n\n\tif (baudrate > QCA_BAUDRATE_3000000)\n\t\treturn -EINVAL;\n\n\tcmd[4] = baudrate;\n\n\tskb = bt_skb_alloc(sizeof(cmd), GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR("Failed to allocate memory for baudrate packet");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Assign commands to change baudrate and packet type. */\n\tmemcpy(skb_put(skb, sizeof(cmd)), cmd, sizeof(cmd));\n\thci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\n\n\tskb_queue_tail(&qca->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\t/* wait 300ms to change new baudrate on controller side\n\t * controller will come back after they receive this HCI command\n\t * then host can communicate with new baudrate to controller\n\t */\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule_timeout(msecs_to_jiffies(BAUDRATE_SETTLE_TIMEOUT_MS));\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\treturn 0;\n}\n\nstatic int qca_setup(struct hci_uart *hu)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct qca_data *qca = hu->priv;\n\tunsigned int speed, qca_baudrate = QCA_BAUDRATE_115200;\n\tint ret;\n\n\tBT_INFO("%s: ROME setup", hdev->name);\n\n\t/* Patch downloading has to be done without IBS mode */\n\tclear_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags);\n\n\t/* Setup initial baudrate */\n\tspeed = 0;\n\tif (hu->init_speed)\n\t\tspeed = hu->init_speed;\n\telse if (hu->proto->init_speed)\n\t\tspeed = hu->proto->init_speed;\n\n\tif (speed)\n\t\thci_uart_set_baudrate(hu, speed);\n\n\t/* Setup user speed if needed */\n\tspeed = 0;\n\tif (hu->oper_speed)\n\t\tspeed = hu->oper_speed;\n\telse if (hu->proto->oper_speed)\n\t\tspeed = hu->proto->oper_speed;\n\n\tif (speed) {\n\t\tqca_baudrate = qca_get_baudrate_value(speed);\n\n\t\tBT_INFO("%s: Set UART speed to %d", hdev->name, speed);\n\t\tret = qca_set_baudrate(hdev, qca_baudrate);\n\t\tif (ret) {\n\t\t\tBT_ERR("%s: Failed to change the baud rate (%d)",\n\t\t\t       hdev->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t\thci_uart_set_baudrate(hu, speed);\n\t}\n\n\t/* Setup patch / NVM configurations */\n\tret = qca_uart_setup_rome(hdev, qca_baudrate);\n\tif (!ret) {\n\t\tset_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags);\n\t\tqca_debugfs_init(hdev);\n\t}\n\n\t/* Setup bdaddr */\n\thu->hdev->set_bdaddr = qca_set_bdaddr_rome;\n\n\treturn ret;\n}\n\nstatic struct hci_uart_proto qca_proto = {\n\t.id\t\t= HCI_UART_QCA,\n\t.name\t\t= "QCA",\n\t.manufacturer\t= 29,\n\t.init_speed\t= 115200,\n\t.oper_speed\t= 3000000,\n\t.open\t\t= qca_open,\n\t.close\t\t= qca_close,\n\t.flush\t\t= qca_flush,\n\t.setup\t\t= qca_setup,\n\t.recv\t\t= qca_recv,\n\t.enqueue\t= qca_enqueue,\n\t.dequeue\t= qca_dequeue,\n};\n\nint __init qca_init(void)\n{\n\treturn hci_uart_register_proto(&qca_proto);\n}\n\nint __exit qca_deinit(void)\n{\n\treturn hci_uart_unregister_proto(&qca_proto);\n}\n';
},function(t,e){"use strict";!function(){function t(t){return a[parseInt(t*s,10)]}function e(t){return console&&console.log&&console.log("Error!",t),!1}function n(t){var n=this,a=this.el=t.el;this.container=t.container,this.fn="function"==typeof t.fn?t.fn:null,this.width="number"==typeof t.width?t.width:150,this.color=!!t.color,this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d");var s=a.nodeName;if("IMG"===s)n.render(),a.addEventListener("load",function(){n.render()});else if("VIDEO"===s){if(this.interval="number"==typeof t.interval?t.interval:15,this.webrtc=!!t.webrtc,this.webrtc){if("function"!=typeof navigator.getUserMedia)return e(a.innerHTML="Error: browser does not support WebRTC");navigator.getUserMedia({video:!0,audio:!1},function(t){n.mediaStream=t,a.src=(window.URL||window.webkitURL).createObjectURL(t)},e)}a.addEventListener("loadeddata",function(){n.play()})}}navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;var a=["@","#","$","=","*","!",";",":","~","-",",",".","&nbsp;","&nbsp;"];a=["&nbsp;","&nbsp;",".",",","-","~",":",";","!","*","=","$","#","@"];var s=a.length-1;n.prototype.play=function(){var t=this;return t.pause().videoTimer=setInterval(function(){!t.mediaStream&&t.webrtc||t.render()},t.interval),t},n.prototype.pause=function(){return this.videoTimer&&clearInterval(this.videoTimer),this},n.prototype.dimension=function(t,e){return"number"==typeof t&&"number"==typeof e?(this._scaledWidth=this.canvas.width=t,this._scaledHeight=this.canvas.height=e,this):{width:this._scaledWidth,height:this._scaledHeight}},n.prototype.render=function(){var t,e,n,a=this.el,s=a.nodeName,i=this.dimension();if(i.width&&i.height||(t="IMG"===s?a.height/a.width:a.videoHeight/a.videoWidth,this.dimension(this.width,parseInt(this.width*t,10)),i=this.dimension()),e=i.width,n=i.height,e&&n){this.ctx.drawImage(this.el,0,0,e,n),this.imageData=this.ctx.getImageData(0,0,e,n).data;var r=this.getAsciiString();this.container&&(this.container.innerHTML=r),this.fn&&this.fn(r)}},n.prototype.getAsciiString=function(){for(var e=this.dimension(),n=e.width,a=e.height,s=n*a,i=this.imageData,r="",_=function(t){return[i[t*=4],i[t+1],i[t+2]]},o=0;o<s;o++){o%n===0&&(r+="\n");var c=_(o),u=Math.max(c[0],c[1],c[2])/255;r+=this.color?'<font style="color: rgb('+c.join(",")+')">'+t(u)+"</font>":t(u)}return r},window.Jscii=n}()},,,,,,,,,,,,,function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},function(t,e){},,,,,,,,,,,,,function(t,e,n){t.exports=n.p+"static/img/amy.a7fc195.png"},function(t,e,n){t.exports=n.p+"static/img/charna.aeb5628.png"},function(t,e,n){t.exports=n.p+"static/img/del.92abdc1.png"},function(t,e,n){t.exports=n.p+"static/img/ian.638d02f.png"},function(t,e,n){t.exports=n.p+"static/img/keith.6b63371.png"},function(t,e,n){t.exports=n.p+"static/img/tj.3bd54f1.png"},function(t,e,n){t.exports=n.p+"static/img/viola.8d75b50.png"},function(t,e,n){var a,s;n(52),a=n(29);var i=n(84);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=i.render,s.staticRenderFns=i.staticRenderFns,t.exports=a},function(t,e,n){var a,s;n(57),a=n(30);var i=n(90);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=i.render,s.staticRenderFns=i.staticRenderFns,s._scopeId="data-v-c73afbb0",t.exports=a},function(t,e,n){var a,s;n(53),a=n(31);var i=n(85);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=i.render,s.staticRenderFns=i.staticRenderFns,s._scopeId="data-v-1a08c484",t.exports=a},function(t,e,n){var a,s;n(56),a=n(32);var i=n(89);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=i.render,s.staticRenderFns=i.staticRenderFns,s._scopeId="data-v-b0f73184",t.exports=a},function(t,e,n){var a,s;n(51),a=n(33);var i=n(83);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=i.render,s.staticRenderFns=i.staticRenderFns,s._scopeId="data-v-1027e76e",t.exports=a},function(t,e,n){var a,s;n(55),a=n(34);var i=n(87);s=a=a||{},"object"!=typeof a.default&&"function"!=typeof a.default||(s=a=a.default),"function"==typeof s&&(s=s.options),s.render=i.render,s.staticRenderFns=i.staticRenderFns,s._scopeId="data-v-7768a5b6",t.exports=a},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{attrs:{id:"rules"}},["board"==t.step?n("div",[n("div",{attrs:{id:"board-title"}},[t._v("\n      Active Rules\n      "),n("small",[n("span",[t._v("|")]),t._v(" "),n("span",{on:{click:function(e){t.doAction("addRule")}}},[t._v("Add Rule")]),t._v(" "),n("span",[t._v("|")]),t._v(" "),n("span",{on:{click:function(e){t.doAction("removeRule")}}},[t._v("Remove Rule")])])]),t._v(" "),n("div",{attrs:{id:"board"}},t._l(t.rules,function(e){return n("div",[n("div",{staticClass:"rule",class:{removing:e.removing}},[t._v("\n          "+t._s(e.text)+"\n        ")])])}))]):t._e(),t._v(" "),"new rule"==t.step?n("div",{attrs:{id:"new-rule"}},[n("div",{staticClass:"flash-text"},[t._v("\n      NEW RULE\n    ")])]):t._e(),t._v(" "),"remove rule"==t.step?n("div",{attrs:{id:"new-rule"}},[n("div",{staticClass:"flash-text"},[t._v("\n      REMOVING RULE\n    ")])]):t._e(),t._v(" "),"read rule"==t.step?n("div",[n("TypeAndSay",{attrs:{timeout:40,doneReading:t.doneReading}},[t._v("\n      "+t._s(t.readRuleText)+"\n    ")])],1):t._e(),t._v(" "),"closer"==t.step?n("div",[n("div",{class:{"flash-text":"closer title"==t.closerStep},attrs:{id:"closer"}},["closer title"==t.closerStep?n("div",[n("div",{staticClass:"flash-text"},[t._v("\n          CLOSER\n        ")])]):t._e(),t._v(" "),"read closer"==t.closerStep?n("div",[n("TypeAndSay",{attrs:{timeout:40,doneReading:t.closerFunc}},[t._v("\n          "+t._s(t.closerText)+"\n        ")])],1):t._e()])]):t._e()])},staticRenderFns:[]}},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{attrs:{id:"app"}},["boot"==t.step.current?n("div",[n("BootAnimation",{attrs:{showStep:t.step}})],1):t._e(),t._v(" "),"intro"==t.step.current?n("div",[n("Intro",{attrs:{names:t.names,step:t.step}})],1):t._e(),t._v(" "),"rules"==t.step.current?n("div",[n("Rules",{attrs:{ruleGens:t.rules,names:t.names}})],1):t._e(),t._v(" "),"simulate"==t.step.current?n("div",[n("Simulation",{attrs:{ruleGens:t.rules,names:t.names}})],1):t._e()])},staticRenderFns:[]}},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{attrs:{id:"boot-animation"}},["fakeCode"==t.step?n("div",{attrs:{id:"fakecode"}},[n("pre",[t._v("\n        "),n("TypeWriter",{attrs:{timeout:40,spliton:"\n"}},[t._v(t._s(t.fakeCode))]),t._v("\n      ")],1)]):t._e(),t._v(" "),"greenFlash"==t.step?n("div",{staticClass:"glitch",attrs:{id:"green-flash"}}):t._e(),t._v(" "),"ascii"==t.step?n("div",{attrs:{id:"ascii"}},[n("pre",{attrs:{id:"loading"}},[t._v("\n        "),n("TypeWriter",{attrs:{timeout:60}},[t._v("\n\nCalibrating comedic timing...\nNullifying transactions...\nFinding light...\nSimulating montage...\n\n        ")]),t._v("        \n      ")],1),t._v(" "),n("AsciiImage",{attrs:{imagename:t.asciiName}})],1):t._e(),t._v(" "),"title"==t.step?n("div",{class:{inverted:t.titleInverted},attrs:{id:"title"}},[n("div",[t._v("IMPROV")]),t._v(" "),n("div",[t._v("GOD")])]):t._e()])},staticRenderFns:[]}},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"typewriter"},[t._v("\n  "+t._s(t.text)+"\n")])},staticRenderFns:[]}},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{attrs:{id:"simulation"},on:{click:t.simulateShow}},[n("h1",[t._v("Click me to simulate a show")]),t._v(" "),n("div",{attrs:{id:"timeline"}},t._l(t.actions,function(e,a){return n("div",{staticClass:"action",style:{left:t.getActionPos(e,t.actions)}},[n("div",{staticClass:"rules",style:{height:8*e.rules+18+"px",top:8*-e.rules-18+"px"}},[n("span",{staticClass:"text"},[t._v("\n\t\t\t\t\t"+t._s(e.rules)+"\n\t\t\t\t")])]),t._v(" "),n("div",{staticClass:"message",style:{height:a%5*28+20+"px"}},[n("span",{staticClass:"text"},[t._v("\n\t\t\t\t\t"+t._s(e.message)+" "+t._s(t.formatTime(e.time))+"\t\t\t\t\t\t\n\t\t\t\t")])])])}))])},staticRenderFns:[]}},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{attrs:{id:"type-and-say"}},[n("TypeWriter",{attrs:{volume:t.typingVolume,timeout:t.timeout}},[t._t("default")],2)],1)},staticRenderFns:[]}},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{attrs:{id:"intro"}},[n("TypeAndSay",[t._v(t._s(t.message))])],1)},staticRenderFns:[]}},function(t,e,n){t.exports={render:function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"ascii-image",class:{loaded:t.asciiLoaded}},[a("img",{attrs:{id:"image-del",src:n(72)}}),t._v(" "),a("img",{attrs:{id:"image-amy",src:n(70)}}),t._v(" "),a("img",{attrs:{id:"image-charna",src:n(71)}}),t._v(" "),a("img",{attrs:{id:"image-keith",src:n(74)}}),t._v(" "),a("img",{attrs:{id:"image-tj",src:n(75)}}),t._v(" "),a("img",{attrs:{id:"image-ian",src:n(73)}}),t._v(" "),a("img",{attrs:{id:"image-viola",src:n(76)}}),t._v(" "),a("pre",{staticClass:"ascii-text"},[t._v("\n    "+t._s(t.text)+"\n  ")]),t._v(" "),a("div",{staticClass:"loading-cover"})])},staticRenderFns:[]}},,,,function(t,e){}]);
//# sourceMappingURL=app.8eec8666babafd4b59bb.js.map